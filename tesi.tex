\documentclass[12pt]{toptesi}

\TesiDiLaurea{Tesi di Laurea Specialistica}
\ateneo{Politecnico di Torino}
\facolta[III]{Ingegneria}
\corsodilaurea{Ingegneria informatica}
\titolo{Test di accettazione per applicazioni web: tecniche e strumenti}
%\sottotitolo{Tecniche e strumenti}
\candidato{Fabio Sussetto}
\relatore{prof.\ Marco Torchiano}
\sedutadilaurea{Novembre 2011}
\logosede{logopolito}


\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{toptesi}
\usepackage{color}
\usepackage{epstopdf}

\usepackage{listings}
\usepackage{spverbatim}

\usepackage{color}
\usepackage{textcomp}

\usepackage[hyphens]{url}
\usepackage[breaklinks]{hyperref}

\usepackage{natbib}

\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}

\definecolor{listinggray}{gray}{0.2}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
	backgroundcolor=\color{lbcolor},
	tabsize=4,
	rulecolor=,
	language=ruby,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=true,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.133,0.545,0.133},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        numbers=left, 
        stepnumber=1
}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{Javascript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\def\hlinewd#1{%
\noalign{\ifnum0=`}\fi\hrule \@height #1 %
\futurelet\reserved@a\@xhline} 

\begin{document}

\author{Fabio Sussetto}

\frontespizio

\indici

\include{chapters/chapter1}

\include{chapters/chapter2}

\include{chapters/chapter3}

\include{chapters/chapter4}

\include{chapters/chapter5}

\include{chapters/chapter6}

\chapter{Considerazioni finali}

Durante la trattazione della tesi, sono stati analizzati diversi aspetti riguardo all'attività di acceptance testing, nell'ambito delle applicazioni web. L'importanza e la diffusione di quest'ultime stanno hanno visto una rapida crescita negli ultimi anni, rendendole una realtà oramai consolidata. 

Le caratteristiche particolari tipiche di un'applicazioni web hanno incentivato la nascita di nuove tecnologie e metodologie di sviluppo più adatte rispetto a quelle tradizionalmente usate in ambito tradizionale. Di conseguenza, ciò ha reso necessario adattare a queste nuove tecnologie le tecniche per l'attività di testing, fondamentale anche per questa tipologia di applicazioni.

All'interno di questo ambito, si è posta l'attenzione in particolare sul test di accettazione di applicazioni web, che interessa tutti i livelli architetturali del software, ma che si è rivelato essere strettamente collegato alla verifica del funzionamento dell'interfaccia grafica.

Dopo un'analisi preliminare degli strumenti di testing esistenti, si è scelto di realizzare un software in grado di acquisire automaticamente una sequenza di operazioni svolte dall'utente durante l'uso dell'applicativo web, accompagnate da azioni di verifica per accertarne il corretto funzionamento, e di riprodurle in un secondo momento tramite una simulazione. Rispetto agli strumenti analizzati, il software proposto si propone due obiettivi principali. 

Il primo obiettivo principale consiste nell'implementazione di un sistema che assista l'utente nell'attività di testing, generando automaticamente i selettori necessari ad individuare gli elementi di interesse della pagina web, sia per la registrazione degli eventi, sia per le verifiche da effettuare. La scelta di un selettore adatto è infatti uno dei punti chiave per assicurare ai test una certa flessibilità alle modifiche che inevitabilmente verranno apportate sia nel breve che nel lungo periodo all'applicazione web in esame, durante lo sviluppo incrementale. Inoltre, è una delle attività che richiedono più tempo, poiché senza un supporto automatico è necessario analizzare manualmente il DOM di ogni pagina per stabilire un selettore adatto. In mancanza di un criterio obiettivo inoltre questa operazione dipende in maniera completa dall'esperienza e dalla capacità di valutazione dell'utente.

Il secondo obiettivo consiste invece nel permetterne l'uso dello strumento realizzato senza dover necessariamente possedere competenze tecniche riguardanti HTML, CSS ed XPath. Tutti gli strumenti analizzati già esistenti infatti richiedono in molti casi l'inserimento manuale dei selettori necessari, dei comandi di verifica o di alcuni accorgimenti particolari, specialmente nel caso di applicazioni che fanno uso della tecnologia AJAX. Tali requisiti consentono però l'utilizzo effettivo degli strumenti di testing solamente a chi possiede competenze da programmatore. 

Se ciò è inevitabile per alcune tipologie di test, come gli unit test o i functional test, per il caso dei test di accettazione è invece più opportuno ed efficace che essi possano essere definiti ed eseguiti in maniera autonoma dal committente del software in esame, che ne stabilisce i requisiti necessari.

Il software realizzato esplora un approccio alternativo anche dal punto di vista tecnologico. In fase di acquisizione dei test, tutti gli strumenti presi in esame devono interoperare con un'istanza del browser eseguita in un processo separato e sono pertanto soggetti a problematiche e limitazioni dovute alla comunicazione tra processi. Per ovviare a questi problemi, si è costretti a ricorrere ad un'architettura complessa, che ha richiesto nella maggior parte dei casi un server HTTP apposito, un socket locale ed un protocollo di comunicazione tra il server e un'estensione del browser. 

Sebbene questa architettura costituisca un buon punto di partenza in fase di riproduzione dei test per pilotare browser differenti, può risultare limitante in fase di acquisizione. Lo strumento realizzato sfrutta il motore di rendering WebKit e lo integra all'interno dell'applicazione stessa tramite il framework Qt. In questo modo si è dimostrato possibile comunicare in maniera decisamente più semplice con le pagine web da esaminare, semplificando l'architettura necessaria in fase di acquisizione.

Uno dei punti di maggiore interesse riscontrati nell'implementazione risiede proprio nella facilità di interazione tra la parte di applicazione desktop e l'applicazione web eseguita all'interno del componente QWebKit. Il meccanismo QtWebKitBridge permette infatti di stabilire un canale di comunicazione bidirezionale con l'interprete Javascript e di mappare oggetti di tipo QObject, definiti in Python, con oggetti Javascript accessibili nel contesto della pagina web.

Riguardo queste considerazioni, QtWebKit sembra molto promettente per il suo utilizzo in ambito di test anche in ottica futura. Secondo quanto disponibile nella roadmap del progetto \footnote{\url{http://trac.webkit.org/wiki/QtWebKitTodo}}, nelle versioni successive a quella attuale si potenzierà notevolmente l'API per interagire con il DOM delle pagine web tramite i moduli QWebPage e QWebFrame, aggiungendo il mapping diretto tra gli eventi Javascript e gli eventi Qt. Tramite questa caratteristica, sarà possibile migliorare ulteriormente l'accuratezza dei test registrati, in maniera analoga a quanto già dimostrato in fase di riproduzione grazie alla simulazione degli eventi in maniera nativa.

L'algoritmo di generazione dei selettori si è rivelato funzionale durante la prova pratica sul pannello amministrativo di Wordpress. Per migliorare ulteriormente la flessibilità dei test, si potrebbe pensare di sfruttare informazioni aggiuntive relative alla fase di testing, inserite appositamente dagli sviluppatori nel markup della pagina web. Per tale scopo sarebbe utile l'attributo \verb|data| assegnabile ai tag, definito dalla specifica HTML5 per memorizzare metadati arbitrari all'interno dell'albero DOM, come mostrato in \cite{html5Data}. Queste informazioni aggiuntive avrebbero il vantaggio di esulare completamente dalla presentazione del documento, al contrario di quanto avviene ad esempio per l'attributo \verb|class| utilizzato al momento nei selettori generati. L'adozione di questa tecnica richiederebbe però un adattamento del codice HTML esistente per l'applicazione sotto esame, pertanto potrebbe essere impiegata come sistema opzionale per fornire informazioni aggiuntive all'algoritmo.

Sempre riguardo a questo algoritmo, può essere interessante sfruttare il meccanismo di selezione di elementi multipli da parte dell'utente tramite lo strumento picker. Questa possibilità è già implementata per le asserzioni di tipo "AssertCount", per le quali l'utente può selezionare sia l'elemento di interesse, sia l'elemento padre che specifica il contesto nel quale effettuare il conteggio delle occorrenze. Lo stesso sistema può essere adattato ad altri casi d'uso, modificando l'algoritmo in modo da sfruttare le altre informazioni aggiuntive specificate in maniera visiva dall'utente.  

Come ulteriori sviluppi, sarebbe utile espandere l'insieme di azioni e di asserzioni supportate dallo strumento in aggiunta a quelli già presenti, per coprire tutti i casi d'uso tipici durante una simulazione. Inoltre, si potrebbe implementare un sistema per convertire automaticamente i test acquisiti in formato XML nei comandi usati dal protocollo Wire. In questo modo tramite la libreria WebDriver, utilizzata da Selenium, i test potrebbero essere eseguiti direttamente sui maggiori browser. 

\bibliography{biblio}
\bibliographystyle{plainnat}

\end{document}

