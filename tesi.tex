\documentclass[12pt]{toptesi}

\TesiDiLaurea{Tesi di Laurea Specialistica}
\ateneo{Politecnico di Torino}
\facolta[III]{Ingegneria}
\corsodilaurea{Ingegneria informatica}
\titolo{Test di accettazione per applicazioni web: tecniche e strumenti}
%\sottotitolo{Tecniche e strumenti}
\candidato{Fabio Sussetto}
\relatore{prof.\ Marco Torchiano}
\sedutadilaurea{Novembre 2011}
\logosede{logopolito}


\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel}
\usepackage{toptesi}
\usepackage{color}
\usepackage{listings}

\usepackage{color}
\usepackage{textcomp}

\usepackage{hyperref}

\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}

\definecolor{listinggray}{gray}{0.2}
\definecolor{lbcolor}{rgb}{0.9,0.9,0.9}
\lstset{
	backgroundcolor=\color{lbcolor},
	tabsize=4,
	rulecolor=,
	language=ruby,
        basicstyle=\scriptsize,
        upquote=true,
        aboveskip={1.5\baselineskip},
        columns=fixed,
        showstringspaces=false,
        extendedchars=true,
        breaklines=true,
        prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
        frame=single,
        showtabs=false,
        showspaces=false,
        showstringspaces=false,
        identifierstyle=\ttfamily,
        keywordstyle=\color[rgb]{0,0,1},
        commentstyle=\color[rgb]{0.133,0.545,0.133},
        stringstyle=\color[rgb]{0.627,0.126,0.941},
        numbers=left, 
        stepnumber=1
}

\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

\lstdefinelanguage{Javascript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}

\begin{document}

\author{Fabio Sussetto}

\frontespizio

\indici

\include{chapters/chapter1}

\include{chapters/chapter2}

\include{chapters/chapter3}

\include{chapters/chapter4}

\chapter{Algoritmi di selezione degli elementi}

\section{Considerazioni iniziali e prerequisiti}

Al momento della registrazione delle azioni è indispensabile poter generare un selettore CSS che permetta di identificare in maniera univoca l'elemento interessato dall'interazione, per potervi accedere in fase di riproduzione. In aggiunta, il selettore individuato dovrebbe garantire una certa flessibilità ai cambiamenti che possono avvenire nel DOM durante il successivo sviluppo dell'applicazione, per non ritrovarsi con un insieme di test troppo fragili.
Allo stesso tempo però è necessario raggiungere un compromesso accettabile tra la resistenza alle variazioni e l'accuratezza delle verifiche, in modo che queste ultime permettano effettivamente di rivelare i problemi che si presentano.

La soluzione proposta parte da alcune considerazioni di partenza, basate principalmente sulla propria esperienza e sui criteri generali considerati come migliore prassi nella realizzazione di pagine web dinamiche, descritte di seguito. Tali punti non sono da considerarsi come vincoli necessari per il funzionamento dell'algoritmo, ma piuttosto come un'insieme di condizioni sotto le quali esso può esprime il suo funzionamento ottimale. 

\subsection {Validazione della sintassi HTML}

I risultati dell'algoritmo sono da considerarsi prevedibili solamente nel caso che il codice HTML della pagina web su cui esso viene applicato sia valido secondo la DTD dichiarata. Questa condizione presuppone che l'albero del DOM possa essere costruito in maniera corretta e che vengano eliminate possibili ambiguità, difficili da gestire in fase di analisi. I browser tentano di correggere gli errori di sintassi più comuni e spesso i problemi non sono così evidenti ad una semplice verifica visuale del contenuto mostrato. 

In particolare, l'algoritmo sfrutta in maniera intensiva la presenza e la distribuzione del l'attributo id per determinare quali elementi del DOM siano meno soggetti a potenziali cambiamenti. E' quindi importante che l'attributo id venga utilizzato in maniera corretta, secondo le specifiche del W3C, evitandone per esempio la duplicazione. Se per generare le pagine si utilizzano sistemi di gestione dei contenuti (CMS) spesso non si ha il controllo completo sugli attributi id assegnati ai nodi, perciò in tali casi è bene assicurarsi che l'attributo venga adoperato in maniera adeguata.

Per ottenere i migliori risultati è quindi sempre consigliabile assicurarsi di validare il codice HTML delle pagine sotto esame attraverso uno strumento come il W3C Validator [http://validator.w3.org]. Le specifiche dettate da questa organizzazione sono state infatti utilizzate per stabilire un'insieme omogeneo di regole su cui fondare la strategia dell'algoritmo.

Se questo requisito non viene rispettato, potrebbe essere possibile perdere molti dei vantaggi forniti dall'algoritmo in termini di flessiblità ai cambiamenti strutturali delle pagine.

\subsection {Utilizzo dei tag HTML in maniera semantica}

Ogni tipologia di tag HTML disponibile è stato pensato per trasmettere un significato semantico preciso ai contenuti della pagina, e non solamente per regolarne l'aspetto con cui esso viene presentato. La scrittura di codice HTML semantico è oramai diventata una prassi consolidata nello sviluppo di applicazioni web moderne poiché i benefici ottenibili sono molteplici ed interessano ambiti diversi, dalla mantenibilità del codice all'indicizzazione sui motori di ricerca, passando per l'accessiblità.

L'algoritmo proposto cerca di sfruttare per quanto possibile il significato semantico attribuito ai vari elementi della pagina per reperire ulteriori informazioni e stabilire un selettore che tenga in considerazione le porzioni di pagina soggette a modifiche con maggiore probabilità.

Un uso attento della semantica implica generalmente anche la presenza di un minor numero di tag HTML nella pagina, ossia di un albero del DOM più compatto. Ciò favorisce evidentemente la robustezza dei test sull'interfaccia, sia perché riduce il numero di componenti che possono variare, sia perché i selettori generati sono più semplici ed effettivi. Per gli stessi motivi è opportuno affidare quanto più possibile ai fogli di stile la presentazione del contenuto, senza ricorrere ove non necessario all'aggiunta di codice di markup aggiuntivo per fini prettamente grafici.

In merito a questo criterio non possono esistere regole deterministiche e schemi prefissati da seguire. E' quindi responsabilità di chi si occupa dello sviluppo dell'interfaccia utente dell'applicazione web la scrittura di codice che faciliti la fase di verifica. L'algoritmo proposto cerca infatti di fornire supporto per stabilire la strategia di selezione degli elementi, ma l'uso di uno strumento automatico può sfruttare ma non può sostituire il lavoro svolto a monte per scrivere codice di qualità. Questa affermazione d'altronde è valida nell'ambito dei test in ogni dominio: più il codice sotto esame è ben organizzato, più sarà facile verificarne il funzionamento dall'esterno.

\section{Idee ed ipotesi di partenza}

Il funzionamento dell'algoritmo fonda le sue basi su di un modello empirico e non su concetti dimostrabili a priori, poiché le differenti casistiche che si presentano esaminando applicazioni web reali sono in numero potenzialmente infinito. Pertanto i punti di partenza sono stati forniti dalla propria esperienza nella realizzazione di pagine e di applicazioni web utilizzando le tecnologie più recenti, e dall'osservazione diretta di casi significativi.

Gli spunti raccolti hanno contribuito a definire una serie di criteri adattabili alle situazioni comuni, attraverso i quali l'algoritmo tenta di risolvere i problemi tipici presenti nel test di applicazioni web. L'obiettivo principale è riuscire a stabilire un selettore CSS che identifichi l'elemento corretto nonostante le possibili modifiche che interessino i suoi attributi, quelli dei nodi appartenenti alla sua linea gerarchica e il suo posizionamento nel DOM. A seguire viene presentato un elenco delle variazioni più comuni, per chiarificare i concetti esposti fino ad ora.

\subsection {Schemi tipici di variazioni nel DOM}

Nella figura ~\ref{fig:domMod} sono presentati i principali schemi individuati secondo i quali avvengono le variazioni nel DOM durante il processo incrementale di sviluppo dell'applicazione web. Nei diagrammi sono evidenziati in arancione i nodi di interesse ai fini del test. 

Le modifiche rappresentate non pregiudicano in linea di massima il funzionamento della pagina in esame: si pensi ad esempio al caso comune in cui si aggiunga un tag div che funge da semplice contenitore, oppure all'aggiunta di una o più classi per ragioni stilistiche. E' quindi importante che il selettore tenga in considerazione queste potenziali variazioni in modo che l'elemento interessato sia reperibile anche seguito ad esse, pena il fallimento del test senza un effettivo difetto funzionale.

\begin{figure}[htbp]
\begin{center}
\includegraphics{images/dom_mod.png}
\caption{Principali schemi di modifica del DOM}
\label{fig:domMod}
\end{center}
\end{figure}

\subsection {L'importanza dell'attributo id}

L'algoritmo proposto attribuisce una notevole importanza all'attributo id assegnabile ai tag HTML. Secondo la specifica W3C, l'attributo id deve essere utilizzato come identificatore univoco per un elemento della pagina. Di conseguenza, se in fase di scrittura dell'HTML si sceglie di assegnare questo attributo ad un tag, si può dedurre che esso agli occhi dello sviluppatore svolge un ruolo ben preciso ed ha pertanto la sua importanza nella pagina. Essendo univocamente identificato inoltre sarà sempre possibile accedere a tale elemento indipendentemente dal contesto in cui esso si trova. 

Inoltre, questo identificativo rappresenta il modo più performante e sicuro per accedere all'elemento da codice Javascript, tramite il metodo \verb|document.getElementById|. Siccome spesso l'id viene assegnato proprio con questo scopo, è relativamente poco probabile che esso venga modificato o rimosso in un secondo momento rispetto ad altri attributi, poiché ciò comporterebbe anche la potenziale modifica degli script sviluppati per l'applicazione.

Idealmente, se tutti gli elementi del DOM avessero un attributo id il problema che l'algoritmo tenta di risolvere sarebbe inesistente, poiché la selezione del nodo di interesse non dovrebbe tener conto della posizione nell'albero. Questa osservazione giustifica di fatto il peso che l'algoritmo gli assegna. 

Più l'albero del DOM è complesso, più alta è la probabilità che si verifichi prima o poi una variazione che interessi indirettamente il percorso verso il nodo di interesse. L'algoritmo cerca pertanto di semplificare le condizioni di partenza lavorando su di un sottoalbero che contiene il nodo da selezionare. Come radice di questo sottoalbero viene scelto il primo nodo antenato che possiede un attributo id, incontrato visitando in maniera bottom-up la gerarchia del nodo da selezionare. 

Nel caso banale in cui il nodo da selezionare possieda egli stesso un id, il sottoalbero coinciderà con esso. Negli altri casi invece si avrà come punto di partenza del selettore un nodo con attributo id, che quindi avrà le proprietà descritte poco prima, limitando quindi le potenziali combinazioni di variazioni relativamente alla struttura dell'intero documento. Per costruzione il selettore CSS risultante avrà in prima posizione un frammento di tipo id, che sarà anche l'unico presente, nel caso in cui nodo abbia almeno un elemento antenato con questo attributo impostato. 

\begin{figure}[htbp]
\begin{center}
\includegraphics{images/id_partition.png}
\caption{Identificazione del sottoalbero a partire dall'ID}
\label{fig:idPartition}
\end{center}
\end{figure}

Il problema di selezionare in modo flessibile i vari componenti in fase di testing è una problematica che come si è detto interessa anche le applicazioni tradizionali con interfaccia grafica. In questo ambito una delle soluzioni spesso utilizzate comporta l'utilizzo di una o più classi ausiliarie che svolgono il ruolo di repository per i componenti. Tramite queste classi è possibile accedere in maniera opaca ai vari widget durante i test, poiché esse implementano al loro interno la logica per individuare il componente, mappandone la reale posizione ad un identificativo. Quando viene modificata la struttura dell'interfaccia, è quindi sufficiente modificare il codice in un solo punto, senza modificare l'implementazione dei test.

Nel caso delle applicazioni web con interfaccia in HTML, l'attributo può svolgere concettualmente lo stesso ruolo dell'identificativo nel repository dei widget, con il vantaggio che questa possibilità è intrinseca alla tecnologia utilizzata.

Durante lo sviluppo dell'interfaccia è buona norma quindi procedere con un occhio di riguardo per la successiva fase di acceptance testing e adoperare gli accorgimenti necessari per renderla più facile. Per quanto visto fino ad ora, può essere molto utile assegnare gli attributi id agli elementi più importanti della pagina, che permettono all'utente di attivare le funzionalità principali oppure che forniscono le informazioni di maggiore interesse, e tenere il più possibile costanti i valori di questi identificativi durante le successive modifiche, in modo da non influenzare i test definiti.

\subsection {L'attributo role}

Un altro importante attributo utilizzato dall'algoritmo è l'attributo \verb|role|. Se presente, esso serve ad indicare uno o più ruoli che l'elemento possiede nell'ambito della pagina. Un corretto uso semantico di questo attributo viene illustrato nella specifica del W3C [\url{http://www.w3.org/TR/xhtml-role/#s_role_module_attributes}]:

\lstinputlisting[language=Html, caption={Esempio di uso semantico dell'attributo role}, label=code:roleAttr]{code/selector/w3c_role.html}

Se chi ha scritto il codice HTML ha inserito questo attributo in un tag, con molta probabilità il suo valore può essere un buon candidato per selezionare l'elemento stesso in mancanza di un attributo id, oppure per costruire il percorso verso l'elemento da selezionare se l'attributo si trova su di un elemento antenato. 

In quest'ultimo caso l'attributo può aiutare ad identificare il sottoalbero in cui si trova l'elemento di interesse, corrispondente ad un'area nella pagina web.

\subsection {Selettori per elementi particolari}

In base al tipo e valore semantico dell'elemento da selezionare, l'algoritmo adopera una strategia particolare per un sottoinsieme di elementi DOM che hanno attributi particolari:

\begin{description}
\item[Campi di input] Alcuni tipi di tag HTML sono definiti per permettere all'utente di inserire dei dati in ingresso, processabili poi lato server. La loro strategia di selezione è pertanto fondamentale in fase di testing. Per questi elementi di input, come caselle di testo, caselle di spunta, menù a tendina, è di particolare interesse l'attributo \verb|name|. 

Il valore assegnato a tale attributo viene utilizzato nell'invio della richiesta HTTP successiva alla sottomissione del form come chiave che identifica il dato inserito dall'utente nel relativo campo. Lato server l'applicazione utilizza quindi il valore dell'attributo \verb|name| per accedere al dato inviato. Siccome esiste questa dipendenza all'interno dell'applicazione, è poco probabile che l'attributo name venga modificato in seguito a modifiche grafiche nel layout della pagina.Per questo motivo, è un ottimo candidato per identificare in maniera consistente e robusta il nodo del DOM in mancanza dell'attributo id.

\item[Label] Il tag \verb|label| è stato definito appositamente per comunicare all'utente il tipo di dato a inserire in un campo di testo. L'algoritmo ne utilizza l'alttributo \verb|for|, che se presente specifica l'id del campo di input a cui si riferisce il testo dell'etichetta. Per gli stessi motivi indicati nel punto precedente è possibile sfruttare questa informazione aggiuntiva nel selettore generato.

\item[Liste] Per definire liste ordinate di elementi in una pagina in maniera semantica si utilizza l'apposito tag \verb|ol|. Nel selettore CSS che individua un particolare elemento di questo tipo di liste l'algoritmo ne specifica sempre l'ordine, utilizzando lo pseudo selettore \verb|:eq(n)| messo a disposizione dalla libreria jQuery, che estende le capacità dei selettori CSS con alcuni pseudo-selettori aggiuntivi.

\item[Collegamenti ipertestuali] Anche i collegamenti ipertestuali giocano un ruolo centrale durante la fase di testing. Nel caso in cui non siano definiti attributi di tipo id o class, l'algoritmo utilizza lo pseudo selettore \verb|:contains()| di jQuery, che seleziona un elemento in base al testo contenuto.

Le alternative analizzate per questo particolare caso sono state la selezione in base alla posizione rispetto al nodo padre oppure in base all'url specificato nell'attributo \verb|href|. Entrambe queste alternative si sono però rivelate meno efficaci. La posizione è infatti una variabile poco significativa, che rende la selezione troppo fragile alle modifiche. Il valore dell'alttributo \verb|href| invece è stato scartato poiché l'url di un link è eccessivamente soggetto a modifiche interne all'applicazione, anche di piccola entità come l'aggiunta di un parametro alla querystring o casistiche simili.

\end{description}

\subsection {Descrizione dell'algoritmo}

All'interno dell'applicazione sviluppata, si è implementato l'algoritmo proposto utilizzando il linguaggio Javascript e la libreria jQuery. Quest'ultima è stata impiegata in questo ambito per due motivi. In primo luogo, jQuery fornisce dei metodi di navigazione dell'albero DOM molto potenti e di comodo utilizzo, senza bisogno di dover ricorrere all'API di Javascript per reimplementare queste funzionalità. In secondo luogo, jQuery estende le capacità dei selettori CSS3 con nuovi pseudo-selettori, che in alcuni casi rappresentano una scorciatoia per selettori più complessi usati frequentemente, mentre in altri casi esprimono concetti non definibili tramite i selettori standard. In aggiunta, è possibile ampliare questo insieme di pseudo-selettori realizzandone di personalizzati se necessario.

Il funzionamento dell'algoritmo per la generazione dei selettori CSS è diviso in due fasi distinte. 

Nella prima fase si costruisce in maniera ricorsiva il selettore, partendo dal nodo di interesse e visitando l'albero in maniera bottom-up. Durante questo processo sono tenuti in considerazione i criteri esposti in precedenza per comporre le singole parti del selettore, basandosi sull'elemento corrente in ogni iterazione.

Nella seconda fase il selettore così ottenuto viene ottimizzato dal punto di vista delle potenziali variazioni future subite dall'albero del DOM, in seguito a modifiche grafiche o di contenuto dell'applicazione sotto esame. Procedendo per tentativi l'algoritmo tenta di eliminare le componenti non indispensabili, per ottenere un selettore minimo.

Queste due fasi vengono descritte nel dettaglio nei paragrafi seguenti.

\subsubsection {Prima fase: percorso bottom-up}

La prima fase viene realizzata attraverso la funzione \verb|_traverse|. Come parametro in ingresso l'algoritmo si aspetta un riferimento ad un oggetto Javascript che rappresenta il nodo del DOM da selezionare. I passaggi dell'algoritmo sono i seguenti:

\begin{enumerate}
\item Se l'elemento corrente è il tag \verb|body|, la ricorsione viene terminata e si restituisce il selettore generato fin'ora, poiché si è raggiunta la radice dell'albero.
\item Viene prodotto il componente del selettore che specifica l'elemento corrente:
	\begin{enumerate}
		\item Se per l'elemento corrente è stato definito l'attributo id, questo viene aggiunto  in fronte al selettore costruito fino ad ora.
		\item Se l'elemento è di tipo \verb|a|, viene preposto il frammento \verb|a:icontains(<contenuto del tag>)|, che seleziona il nodo che contiene il testo specificato nelle parentesi dello pseudo-selettore jQuery.
		\item Se l'elemento possiede uno o più attributi \verb|role|, viene aggiunto un frammento del tipo \verb|<tipotag>[role=<role>]|.
		\item Se l'elemento è un widget di input e possiede l'attributo \verb|name|, si aggiunge un frammento del tipo \verb|<tipotag>[name=<name>]|
		\item Se l'elemento è una label è presente l'attributo \verb|for| e nella pagina esiste un nodo con attributo id uguale al valore dell'attributo for, si aggiunge un frammento del tipo \verb|<tipotag>[for=<for>]| 
		\item Se l'elemento è una voce di un elenco numerato, viene specificato il numero ordinale che ne indica la posizione tra i figli del nodo \verb|ol| genitore, tramite lo pseudo-selettore \verb|:eq(<indice>)|
		\item Se l'elemento possiede una o più classi, viene presa la prima in ordine di definizione e aggiunto in cima allo stack un componente al selettore del tipo \verb|.<classe>|
		\item Infine, se nessuna delle condizioni precedenti è applicabile, si aggiunge al selettore il nome del tag corrente.
	\end{enumerate}
\item Si verifica se il selettore costruito fino a questo punto identifica uno ed un solo elemento tra tutti i figli del genitore del nodo corrente.
	\begin{enumerate}
		\item Se la verifica ha esito positivo, il selettore generato fino a questo punto è univoco. Si continua la ricorsione richiamando il metodo \verb|_traverse| passandogli come argomenti il padre dell'elemento attuale, che diventerà l'elemento corrente della prossima iterazione, e il vettore contenente le componenti del selettore generate.
		\item In caso contrario, esistono almeno due nodi nella partizione dell'albero visitata che rispondono allo stesso selettore. Siccome questo sarà sempre vero anche per le iterazioni successive, è necessario rimediare al problema. Per far ciò, si ricava l'indice posizionale dell'elemento identificato dal selettore in cima allo stack dei frammenti, relativamente al nodo genitore. Si appende poi a tale frammento lo pseudo-selettore \verb|:eq(<indice>)|. Poiché questa operazione viene effettuata ad ogni iterazione dell'algoritmo, si ha la certezza che il selettore così ottenuto sia univoco per costruzione, poiché l'indice posizionale è l'elemento sicuramente discriminante in caso di ambiguità.
	\end{enumerate}	
	
\end{enumerate}

Al termine di questo procedimento si ottiene quindi un selettore univoco per l'elemento iniziale, composto da un frammento per ogni livello del DOM incontrato nella visita.

\subsubsection {Seconda fase: ottimizzazione del selettore}

Il selettore ottenuto tramite la fase precedente viene semplificato per ottenere un nuovo selettore che identifichi lo stesso elemento di partenza, ma che sia più resistente alle potenziali modifiche apportate alla struttura della pagina.

La fase di ottimizzazione si basa sulla seguente ipotesi, ricavata in maniera empirica durante lo sviluppo delle interfacce di numerose applicazioni web, che si basa sull'osservazione del punto dell'albero DOM in cui avvengono le modifiche durante lo sviluppo dell'interfaccia nel lungo periodo. Considerando come punto di riferimento la posizione nel DOM del nodo selezionato per il test, è più probabile che le modifiche si verifichino nei livelli gerarchici più vicini al punto di riferimento, piuttosto che nei livelli più distanti. Si identifica quindi una certa località nella distribuzione delle modifiche rispetto al nodo di interesse.

Questa ipotesi si fonda sul fatto che la struttura di una pagina web segue normalmente uno schema comune, nella quale gli elementi più in alto nel DOM sono utilizzati per definire la struttura di base del layout grafico, come l'intestazione della pagina, l'area dei contenuti principali, la barra di navigazione laterale, eccetera. E' ragionevole supporre che, una volta definite, queste macro aree rimarranno stabili e non subiranno modifiche continue durante lo sviluppo incrementale dell'interfaccia.

Viceversa, saranno gli elementi più interni a subire il maggior numero di modifiche, con l'aggiunta di nuovo contenuto, nuove voci nei menù, e la riorganizzazione delle strutture interne.

Sfruttando queste considerazioni, l'algoritmo prova a rimuovere progressivamente i frammenti del selettore, partendo dal frammento subito precedente a quello riferito al nodo di interesse, che rimane pertanto sempre presente. Se il selettore ottenuto continua ad identificare univocamente lo stesso elemento di partenza, il frammento corrente viene rimosso e si procede con quello che lo precede. Il procedimento viene interrotto quando si raggiunge il primo frammento di tipo id.

Di seguito vengono esposti nel dettaglio i vari passaggi di questa fase:

\begin{enumerate}
\item Si marca il nodo di partenza aggiungendovi una classe speciale, per poter verificare successivamente se il selettore ottimizzato continua ad identificare effettivamente lo stesso elemento.
\item Il vettore \verb|path| è popolato con i frammenti del selettore ottenuto dalla prima fase. In prima posizione è presente il frammento più generico, in ultima quello relativo al nodo di partenza.   
\item Per ogni elemento del vettore \verb|path|, partendo dal penultimo e procedendo con indice decrescente:
	\begin{enumerate}
		\item Se il frammento corrente è di tipo id, si interrompe l'iterazione e si ritorna il selettore corrente
		\item In caso contrario, si duplica il vettore, si rimuove dalla copia il frammento corrente e si compone il nuovo selettore unendo gli elementi del vettore di prova.
		\item Si recupera l'insieme dei nodi del DOM che rispondono a tale selettore di prova e si verifica che esso sia composto da un unico elemento. Inoltre, questo elemento deve possedere la classe speciale usata come marcatore, per assicurarsi che il selettore identifichi esattamente il nodo di partenza.
		\item Se queste condizioni sono verificate, il vettore di prova diventa il vettore del selettore corrente. L'algoritmo procede e l'analisi si sposta sul frammento precedente.
	\end{enumerate}
\end{enumerate}

\subsection {Esempi pratici}

Verranno ora presentati alcuni esempi pratici di funzionamento dell'algoritmo in scenari d'uso interessanti ai fini della trattazione. Per ogni esempio saranno indicati il selettore ottenuto dalla prima fase, quello finale dopo l'ottimizzazione, e le peculiarità del caso in esame.

Nelle figure inserite si sono evidenziati in rosso il nodo di interesse, preso come punto di partenza dall'algoritmo, in giallo i noti aggiunti o modificati dopo un'ipotetica modifica all'interfaccia grafica dell'applicazione web.

\subsubsection {Aggiunta di elementi contenitori multipli}

Selettore non ottimizzato:  \verb|#content .foo div p| 
\newline
Selettore finale:  \verb|#content p| 

\begin{figure}[htbp]
\begin{center}
\includegraphics{images/dom_examples/wrap.png}
\end{center}
\end{figure}

Il selettore ottimizzato non contiene riferimenti ai nodi intermedi e pertanto continua a selezionare l'elemento corretto anche dopo la modifica evidenziata. Grazie al partizionamento dell'albero basato sull'attributo id più vicino, il selettore si comporta in maniera corretta anche se venisse aggiunto un paragrafo con classe \verb|intro| direttamente sotto il div con id \verb|main|

\subsubsection {Aggiunta di una nuova voce in un menù a più livelli}

Selettore non ottimizzato:  \verb|#menu > li:eq(1) ul > li:eq(1) a:icontains(item3)| 
\newline
Selettore finale:  \verb|#menu a:icontains(item3)| 

\begin{figure}[htbp]
\begin{center}
\includegraphics{images/dom_examples/menu_add_item.png}
\end{center}
\end{figure}

Questo scenario modellizza un caso tipico di modifica apportata al menù di un'applicazione web, ossia l'aggiunta di una voce di menù. L'elemento di interesse è il collegamento ipertestuale con testo "item3" e prima di esso viene aggiunta la nuova voce. 

Come si può notare, il selettore non ottimizzato contiene riferimenti espliciti alla posizione delle voci della lista non ordinata, poiché nessuno dei tag \verb|li| o \verb|a| possiede un attributo di classe. L'unico modo per ottenere un selettore non ambiguo consiste nello specificare l'indice tramite lo pseudo selettore \verb|:eq()|. Inoltre, il nodo finale di tipo \verb|anchor| viene identificato tramite il testo in esso contenuto, tramite lo pseudo selettore \verb|:icontains()|. Per i collegamenti ipertestuali, nella maggior parte dei casi in cui mancano altri attributi più specifici, il testo contenuto nel nodo si rivela un buon elemento di discriminazione, migliore della posizione.

Se l'algoritmo non effettuasse l'ottimizzazione, il selettore risultante non sarebbe sufficientemente flessibile da selezionare comunque la stessa voce del menù in seguito all'aggiunta di una nuova voce in posizione antecedente ad essa, poiché l'indice posizionale risulterebbe alterato.

Durante l'ottimizzazione vengono rimossi questi vincoli di posizione, che di fatto risultano essere ridondanti, poiché esiste un solo tag di tipo \verb|a| che contiene il testo specificato all'interno del sottoalbero che ha \verb|ul#menu| come radice. Grazie a questo accorgimento, il selettore continua  a funzionare anche dopo le modifiche, rendendo i test che lo utilizzano meno fragili. Il risultato che si ottiene è del tutto analogo qualora lo scenario prevedesse la rimozione di una voce di menù invece che l'aggiunta.

\subsubsection {Utilizzo semantico di una lista ordinata}

Selettore non ottimizzato:  \verb|#ordered li:eq(0) a:icontains(item 1)| 
\newline
Selettore finale:  \verb|#ordered li:eq(0) a:icontains(item 1)| 

\begin{figure}[htbp]
\begin{center}
\includegraphics{images/dom_examples/ordered_menu.png}
\end{center}
\end{figure}

A differenza dello scenario precedente, questa volta viene utilizzata una lista ordinata. L'algoritmo utilizza questa informazione semantica e forza nel selettore ottimizzato la presenza dell'indice posizionale. Pertanto il selettore non sarà in grado di identificare alcun elemento dopo le modifiche evidenziate. Siccome si è specificato un tag \verb|ol|, chi ha sviluppato l'interfaccia grafica ha voluto sottolineare l'importanza dell'ordine nell'elenco, pertanto l'algoritmo raccoglie questa indicazione nella semantica e se il selettore viene utilizzato in un test, esso fallirà in seguito all'aggiunta di una nuova voce antecedente poiché non sarà possibile reperire l'elemento specificato.

La verifica dell'ordine può essere infatti un requisito fondamentale nel caso in cui ci si voglia accertare che un menù compaia esattamente come richiesto dal committente, oppure per questioni di accessibilità o comodità d'uso.

\subsubsection {Campi di input}

Selettore non ottimizzato:  \verb|#test > .input:eq(0) input[name=title]| 
\newline
Selettore finale:  \verb|#test input[name=title]| 

\begin{figure}[htbp]
\begin{center}
\includegraphics{images/dom_examples/form1.png}
\end{center}
\end{figure}

Per selezionare un campo di input viene utilizzato preferibilmente il valore dell'attributo \verb|name|. Nel caso mostrato in figura, il selettore generato è abbastanza flessibile da continuare a funzionare anche dopo il cambiamento di tipo e di ordine degli elementi contenitori.

Se invece venisse modificato l'attributo \verb|name| il selettore non sarebbe in grado di accedere al campo di input e sarebbe necessario modificare il test, in modo che rifletta le modifiche apportate. Questa situazione è comunque ragionevole poiché il cambio di nome presuppone un potenziale cambiamento anche alla parte dell'applicazione lato server, pertanto è opportuno ridefinire il passaggio del test interessato per non rischiare di ottenere un falso risultato positivo.

\subsection {Unit test dell'algoritmo}

Il funzionamento dell'algoritmo proposto è stato verificato attraverso un insieme di test definiti in Javascript tramite il framework QUnit. 

Gli unit test scritti verificano l'unicità dell'elemento individuato e la corrispondenza con l'elemento di partenza specificato. Inoltre, gli scenari proposti in precedenza costituiscono il corpo di alcuni dei test effettuati per misurare la flessibilità dei selettori generati rispetto alle modifiche nel DOM.

\chapter{Algoritmo di }

Durante la fase di riproduzione dei test, i selettori generati dall'algoritmo vengono utilizzati per identificare gli elementi della pagina su cui simulare gli eventi o effettuare le verifiche specificate dalle asserzioni.

Nell'ottica di migliorare ulteriormente la resistenza dei test alle modifiche che non influenzano le funzionalità dell'applicazione web, è stato implementato un secondo algoritmo. Esso può essere utilizzato durante la fase di riproduzione per effettuare alcuni tentativi aggiuntivi nel caso in cui non sia possibile individuare nella pagina un nodo del DOM che risponda al selettore specificato nel test.

Questo secondo algoritmo stabilisce quindi alcuni criteri per ottenere un insieme di selettori alternativi a quello di partenza attraverso i quali lo strumento di test tenta di reperire l'elemento di interesse. 

Si noti che è comunque sempre necessario stabilire un compromesso tra la resistenza del test alle modifiche e l'accuratezza delle verifiche effettuate. Se si favorisce eccessivamente il primo tra questi due aspetti, ci si potrebbe trovare con una serie di test che non sono sensibili a potenziali malfunzionamenti dell'applicazione.

Pertanto si è scelto di applicare questo algoritmo soltanto per alcuni tipi di operazioni durante la riproduzione dei test, per le quali risulta poco probabile che il maggior grado di flessibilità fornito possa creare dei falsi positivi nei risultati. Tra tutte le operazioni definibili in un test, quelle rivelatesi più adatte per l'applicazione dell'algoritmo sono state le azioni che simulano la navigazione dell'utente tra le pagine, come il click su di un link o su di un bottone per l'invio di un form.

Durante la riproduzione di queste operazioni infatti è possibile avvantaggiarsi di un margine di tolleranza più ampio nell'accuratezza con cui si identifica dell'elemento obiettivo nella pagina, poiché il rischio di fornire un falso positivo come risultato del test è minore. Per avvalorare questa ipotesi con un esempio pratico, si può osservare che se venisse simulato il click su di un link differente da quello specificato nei test, fallirebbero comunque con grande probabilità tutti i test successivi, definiti su di una pagina che non è in realtà quella caricata dopo il click sul link errato.

Viceversa, in altri tipi di operazioni, come le asserzioni riguardo il contenuto di alcune porzioni della pagina, è preferibile utilizzare il selettore CSS per l'elemento da verificare esattamente come è stato specificato nel test, poiché i selettori alternativi proposti dall'algoritmo potrebbero portare a risultati ambigui.

\section{Principi di base e funzionamento}

Per proporre i selettori alternativi a quello di partenza, durante ogni iterazione dell'algoritmo vengono eliminati i frammenti ai quali viene assegnato un peso minore, in modo da ottenere un selettore via via meno specifico. 

Anche in questo caso, i selettori alternativi vengono proposti in base a due principi già sfruttati per l'algoritmo di generazione del selettore. Il principio di località delle modifiche descritto in precedenza in questo caso viene applicato non direttamente al DOM ma alla gerarchia identificata dal selettore. Ad ogni frammento viene assegnato un certo peso durante la fase di preparazione iniziale, che successivamente viene usato per decidere l'ordine in cui rimuovere i frammenti. I frammenti considerati meno indicativi saranno rimossi nei primi selettori alternativi proposti. L'unico frammento che non verrà rimosso sarà quello in ultima posizione nel selettore di partenza, poiché si riferisce direttamente all'elemento da ricercare. 

Una volta assegnato il peso a ciascun frammento, essi saranno eliminati secondo l'ordinamento rispetto del peso assegnato. Quindi, la probabilità che un frammento venga eliminato durante le prime iterazioni cresce in base al peso assegnatogli.

Nel calcolo del peso di ogni frammento vengono conteggiati due fattori. La prima componente è fissa ed è assegnata in base al tipo di frammento. Il contributo minimo viene assegnato ai frammenti di tipo \verb|id|, per le stesse motivazioni già esposte in precedenza. Il valore assegnato cresce poi per i frammenti di tipo \verb|.class|, fino ad ottenere il valore minimo per i frammenti che specificano solamente il tipo del tag.

La seconda componente invece è proporzionale alla posizione che il frammento occupa nel selettore iniziale. Più sarà distante dal frammento che specifica l'elemento interessato, più il contributo sarà maggiore. Pertanto, a parità di tipo, i frammenti nelle posizioni iniziali avranno un peso maggiore, mentre quelli nelle posizioni finali avranno un peso minore. Questa strategia di fatto sfrutta l'idea della località delle modifiche, poiché i frammenti relativi ad elementi del DOM più vicini a quello selezionato in partenza saranno eliminati per primi con maggiore probabilità nei tentativi effettuati.

Di seguito viene proposta la sequenza delle operazioni compiute dall'algoritmo

\begin{enumerate}
\item La stringa del selettore di partenza viene spezzata e i frammenti inseriti in un vettore
\item Se il vettore contiene un solo elemento, l'algoritmo restituisce l'elemento specificato dal selettore originale, poiché ci si trova in un caso banale e non è possibile proporre alternative.
\item Ogni elemento del vettore viene passato alla funzione \verb|buildItem|, che crea la struttura dati necessaria ed assegna il peso al frammento;
	\begin{enumerate}
		\item Se il frammento corrente è di tipo id, viene assegnato il peso minimo, pari ad 1.
		\item Se il frammento è del tipo \verb|tag.classe|, viene assegnato un peso pari a 10.
		\item Se il frammento specifica solamente una classe, viene assegnato un peso pari a 50.
		\item Se il frammento indica unicamente il tipo del tag, viene assegnato un peso pari a 100.
		\item Il peso assegnato viene moltiplicato per la posizione che il frammento occupa nel vettore.
	\end{enumerate}
\item Finché il vettore dei frammenti contiene almeno un elemento:
	\begin{enumerate}
		\item Si verifica se il selettore costruito dal vettore dei frammenti corrente selezioni un elemento del DOM.
		\item Se ciò è vero, l'algoritmo termina e viene restituito un riferimento al nodo individuato dal selettore corrente.
		\item In caso contrario, si rimuove dal vettore corrente il frammento a cui è assegnato il peso maggiore tra quelli presenti e si procede con l'iterazione successiva.
	\end{enumerate}	
\item Se si è raggiunto il numero massimo di tentativi consentiti senza riuscire ad individuare alcun elemento, viene restituito un riferimento nullo.
\end{enumerate}

Se è necessario, è possibile adattare il comportamento dell'algoritmo all'applicazione in esame agendo in due punti. Modificando il criterio di assegnazione dei pesi si modifica l'ordine dei tentativi effettuati, privilegiando un tipo di frammento piuttosto che un altro. Regolando il numero di tentativi effettuati si aumenta o diminuisce il grado di sensibilità alle variazioni nella struttura della pagina.

\section{Esempi di funzionamento}

\chapter{Prova dello strumento}

Al fine di verificare iil funzionamento e l'effettiva efficacia dello strumento sviluppato e delle strategie analizzate, si è scelto di eseguire alcune prove pratiche di utilizzo in situazioni reali. 

La prima decisione che è stata presa in questo senso ha riguardato l'applicazione web da esaminare. La scelta finale è ricaduta su Wordpress, per i motivi che verranno ora elencati.

Wordpress è l'applicazione web per la pubblicazione la gestione di blog più diffusa al momento, ed è usato come piattaforma di pubblicazione dei contenuti da decine di milioni di siti web [http://en.wordpress.com/stats/]. Vista l'enorme diffusione, non rappresenta un caso di nicchia.

In primo luogo Il progetto è open source sviluppato in PHP, pertanto è possibile accedere al codice sorgente per analizzarne se necessario il funzionamento [http://core.svn.wordpress.org/trunk/]. Nel codice repository dei test [http://svn.automattic.com/wordpress-tests/] accessibile pubblicamente è presente solamente una suite di unit test, pertanto realizzare una serie di test di più alto livello non si è rivelato un esercizio unicamente fine a sé stesso.

Si possiede poi già esperienza nell'utilizzo che nell'estensione di questa piattaforma, pertanto è stato possibile individuare facilmente gli scenari di interesse per i test di accettazione, cercando di evidenziare le situazioni potenzialmente più critiche per valutare il comportamento dello strumento di testing realizzato. 

In aggiunta, la parte di front-end della piattaforma in esame, ossia il pannello di amministrazione, presenta un codice HTML di concezione moderna, ben strutturato ed utilizzato prevalentemente in maniera semantica. Grazie a ciò lo strumento di testing si deve confrontare con un'applicazione web che presenta un sufficiente livello di qualità nella realizzazione dell'interfaccia utente, adatto a soddisfare almeno in parte i requisiti consigliati per il suo impiego.

Infine, l'interfaccia non è particolarmente complessa e non viene fatto un uso intensivo della tecnologia Ajax, utilizzata più che altro per migliorare l'esperienza dell'utente in alcune funzionalità abbastanza marginali. Anche l'organizzazione dei contenuti e le strutture nel DOM del pannello di amministrazione sono piuttosto tipici, pertanto il back-end di Wordpress può essere preso come un campione rappresentativo di molte piattaforme analoghe.

Lo scenario di test analizzato prevede alcune operazioni comuni all'interno del sistema Wordpress, come l'accesso dell'amministratore dalla pagina di login e l'inserimento di un nuovo articolo del blog. La sequenza delle operazioni è stata registrata e poi riprodotta sulla versione 2.8 di Wordpress, installata in locale. In un secondo momento, lo stesso test definito in precedenza è stato riprodotto sulla versione 3.1, che presenta alcune differenze nel layout grafico, nella distribuzione dei contenuti e nella struttura dell'HTML, rimanendo però analoga sia per le funzionalità offerte sia per il modo in cui esse vengono attivate dall'utente. 

In questo modo è stato possibile fare una prima valutazione pratica circa la resistenza dei test registrati ai cambiamenti nel DOM delle pagine, considerando un caso reale di evoluzione nell'interfaccia e non semplicemente una serie di modifiche ad hoc.

\section{Descrizione del primo esperimento}

\subsection{Preparazione dello strumento e definizione del punto di partenza per il test}

Una volta avviato il programma, si attiva la modalità di registrazione premendo l'apposito pulsante nella barra degli strumenti principale, si digita l'indirizzo stabilito come punto di partenza per il test e si preme il pulsante "Visit". Poiché si è in modalità di registrazione, viene creata la prima azione nella lista a destra della finestra. Questa azione corrisponde alla navigazione dell'utente ad un indirizzo specificato ed essendo la prima che è stata definita farà in modo che il simulatore si porti sempre sulla pagina iniziale prima di effettuare le altre azioni.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\textwidth]{images/wp_tour/1_login.png}
\end{center}
\end{figure}
 

\subsection{Pagina di login}

Sempre con la modalità di registrazione attivata, si inseriscono il nome utente e la password negli appositi campi. Quando una casella di testo perde il focus ed il suo contenuto non è nullo, viene aggiunta l'azione "Fill input", che rappresenta l'inserimento di una serie di caratteri da parte dell'utente nella casella di testo correntemente attiva. 

Espandendo la riga dell'azione di tipo "Fill input" appena creata, si può osservare che sono state registrate automaticamente anche due informazioni essenziali per riprodurre in seguito l'azione, ossia il selettore ed il valore immesso nel campo. Scendendo nel dettaglio, l'evento Javascript \verb|blur| viene intercettato dal codice presente nel file \verb|logger.js|. Tramite jQuery viene reperito il valore presente nel campo di testo e viene cercato un tag di tipo \verb|label| associato al campo tramite l'attributo \verb|for|, oppure che contenga al suo interno il campo. Se l'etichetta viene trovata, se ne ottiene il testo contenuto.

Inoltre, viene richiamata la funzione che costruisce il selettore secondo l'algoritmo esposto in precedenza, passando come argomento il riferimento al nodo del DOM corrente, ossia il campo di testo.

A questo punto viene richiamato nello script l'apposito metodo dell'oggetto Python di classe \verb|Logger|, reso disponibile nel contesto della pagina sotto forma di oggetto Javascript, passando come parametri il selettore, il valore del campo, il ed il contenuto della label, se presente. Quest'ultimo viene mostrato all'utente nella lista delle azioni in modo che sia chiaro quale campo è stato compilato, rendendo più leggibile il test che si sta registrando.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\textwidth]{images/wp_tour/2_fill_login.png}
\end{center}
\end{figure}

Premendo poi il pulsante "Login" viene registrata l'azione corrispondente, in maniera analoga a quanto appena descritto. Fino a che il caricamento della pagina successiva non è completato, viene mostrato un messaggio che avvisa di attendere e viene inibita la registrazione di nuove azioni, per evitare possibili inconsistenze dovute alla situazione non stabile della pagina. Inoltre viene aggiornato il contenuto della barra dell'indirizzo con l'url della pagina corrente.

\subsection{Dashboard}

Una volta terminato il login, si procede a definire la prima asserzione, che permette di assicurarsi che il login sia effettivamente andato a buon fine e che ci si trovi nella pagina della dashboard. 

Per fare ciò, dopo aver cliccato sul pulsante nella barra degli strumenti per aggiungere una nuova asserzione, viene aperta una finestra di dialogo attraverso la quale inserire le informazioni per la nuova asserzione. Si procede selezionando il tipo di asserzione da aggiungere, scegliendo tra quelle disponibili. Per il tipo "Element contains" viene controllato in fase di riproduzione che l'elemento specificato sia presente nella pagina e nel testo contenuto sia presente la stringa di testo specificata nell'apposito campo.

Il selettore all'elemento che sarà oggetto della verifica può essere inserito manualmente, oppure può essere generato automaticamente dall'algoritmo. Per seguire questa seconda opzione, è necessario cliccare sul pulsante "Pick". La finestra di dialogo sarà così temporaneamente nascosta e sulla pagina verrà attivata la modalità di selezione. 

In questa modalità, viene disegnato tramite Javascript un bordo attorno all'elemento sottostante al puntatore del mouse, cosicché l'utente possa scegliere l'elemento che deve essere oggetto dell'asserzione cliccando sull'elemento evidenziato.

Per realizzare questa funzionalità, si è rivelato necessario giustapporre quattro nodo di tipo \verb|div| all'elemento target dell'evento \verb|mouseover|. Questi elementi fittizi vengono posizionato in maniera assoluta e sovrapposti al contenuto della pagina tramite la regola CSS \verb|z-index|. Ognuno di essi rappresenta una delle quattro regioni attorno al rettangolo che individua virtualmente l'elemento sotto il puntatore del mouse, e per ciascuno viene impostato tramite CSS un bordo rosso per il lato che combacia con l'elemento. Questa soluzione più complicata si è resa necessaria per evitare possibili modifiche al layout della pagina dovute al modo in cui opera il box model definito per la specifica CSS. 

Se si fosse semplicemente assegnato un bordo all'elemento da evidenziare si sarebbero infatti alterate le dimensioni dell'elemento, poiché lo spessore del bordo viene conteggiato sia nel calcolo dell'altezza che in quello della larghezza dell'elemento. Questo può provocare uno spostamento indesiderato nel layout della pagina, qualora l'allineamento degli elementi dipenda dalle esatte dimensioni degli stessi.

Una volta che viene effettuato il click sul nodo evidenziato, quest'ultimo viene passato come parametro di ingresso all'algoritmo di generazione dei selettori. Dal contesto Javascript il selettore ed il testo contenuto nell'elemento vengono resi disponibili alla parte in Python tramite l'oggetto condiviso di classe \verb|Logger|. Esso emette il segnale PyQt \verb|pathPicked| e l'applicazione può mostrare nuovamente la finestra di dialogo, con il campo per specificare il selettore impostato al valore generato via Javascript.

Una volta applicate le impostazioni per la nuova asserzione, viene creata la relativa riga nella lista delle azioni registrate. Durante la fase di riproduzione, l'asserzione verrà eseguita quando il simulatore raggiungerà lo step corrispondente, secondo l'ordine mostrato.

Per questa asserzione, il selettore restituito risulta essere \verb|#wpbody-content h2|. La struttura del DOM in cui si trova l'elemento è quella mostrata in figura ~\ref{fig:dashboardH2DOM}, ricavata tramite l'estensione Firebug. Come si può osservare, il selettore generato non tiene conto del nodo \verb|div.wrap|, poiché esiste un solo tag \verb|h2| all'interno del sottoalbero che ha come radice il nodo \verb|div#wpbody-content|. 

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\textwidth]{images/wp_tour/7_dashboard_h2_firebug.png}
\caption{Porzione dell'albero del DOM per il titolo "Dashboard"}
\label{fig:dashboardH2DOM}
\end{center}
\end{figure}

\subsection{Pagina per la pubblicazione di un nuovo articolo}

\subsubsection{Click nel menù principale}

Per raggiungere la pagina di inserimento di un nuovo articolo, si clicca sulla voce nel menù principale a sinistra. Viene registrata l'azione corrispondente e il selettore ottimizzato restituito per il collegamento cliccato è \verb|#menu-posts a:icontains(add+new)|. La reale struttura del DOM è mostrata in figura ~\ref{fig:addNewDOM}: in questo caso i nodi intermedi tra il collegamento ipertestuale ed il nodo \verb|li#menu-posts| sono stati ignorati dall'algoritmo e non compaiono nel selettore finale. Siccome poi è stata utilizzata una lista di tipo non ordinato, nel selettore non è presente un'indicazione sulla posizione della voce contenente il link cliccato. E' pertanto possibile aggiungere nuove voci al menù, oppure modificare l'ordinamento delle voci o il tipo di tag utilizzati, senza dover modificare il test in un secondo momento. Una modifica che invece potrebbe rendere necessaria la ridefinizione di questo passaggio nel test consiste nell'aggiungere una nuova voce nel menù che contenga la stringa "add new" in posizione precedente rispetto al nodo di riferimento.

Siccome nel codice HTML è stato assegnato un attributo \verb|id| alla voce del menù che contiene a sua volta il sottomenù con i collegamenti per le azioni riguardanti gli articoli, il test verifica anche implicitamente che il collegamento "Add new" si trovi nella corretta sezione del menù. La sezione riguardante le azioni sugli articoli è infatti identificata dal sottoalbero identificato dall'algoritmo tramite l'attributo \verb|id| definito sulla voce della lista.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\textwidth]{images/wp_tour/8_add_new_firebug.png}
\caption{Porzione dell'albero DOM per il menù principale}
\label{fig:addNewDOM}
\end{center}
\end{figure}

A questo punto viene inserito il testo del titolo per il nuovo articolo. Il tag HTML del campo possiede un attributo di tipo \verb|id|, quindi il selettore generato risulta essere semplicemente \verb|#title|. Nel caso in cui non fosse stato definito questo attributo, l'algoritmo avrebbe utilizzato l'attributo \verb|name| per identificarlo.

\subsubsection{Creazione ed assegnamento di una nuova categoria via Ajax}

Il passo successivo nel test prevede l'assegnamento dell'articolo ad una nuova categoria. Per facilitare questa operazione, tramite l'interfaccia l'utente può creare direttamente una nuova categoria prima di selezionarla, senza dover lasciare la pagina corrente. La nuova categoria verrà infatti salvata nel database tramite una richiesta asincrona.

Questa operazione ha fatto emergere poi un altro interessante aspetto, che ha richiesto un ripensamento della strategia con cui vengono intercettati gli eventi tramite Javascript.

Il campo per inserire il titolo della nuova categoria e il bottone di conferma sono inizialmente nascosti, e vengono mostrati solamente dopo il click sul link "Add new category". Durante i primi esperimenti, l'evento di click su questo link non veniva però intercettato dal codice Javascript utilizzato per la registrazione.

Dopo aver analizzato la porzione del codice di Javascript usato in Wordpress per questa operazione, riportato nel listato ~\ref{code:wpReturnFalse} ci si è accorti che il problema risiede nel fatto che la funzione ritorna il valore \verb|false|.
Questo valore viene restituito poiché si desidera che il browser non esegua l'operazione tipica che accade al click su di un link, ossia la visita dell'indirizzo (o del frammento) specificato nell'attributo \verb|href|. Come effetto collaterale però viene annullata la propagazione dell'evento nel DOM, che non raggiungerà mai il nodo \verb|body|, sul quale sono definiti gli event handler tramite il metodo jQuery \verb|.live|, che intercettato gli eventi per la registrazione.

In realtà il problema non si sarebbe posto se fossero stati usati nel codice di Wordpress i metodi Javascript adatti. Gli oggetti di tipo \verb|event| possiedono infatti alcuni metodi apposta per avere un maggiore controllo in questa situazione: sarebbe stato più adeguato utilizzare il metodo \verb|event.preventDefault|, che impedisce proprio al browser di eseguire l'azione standard ma non blocca la propagazione dell'evento.

\lstinputlisting[language=Javascript, caption={Codice Javascript usato in Wordpress per mostrare i campi nascosti}, label=code:wpReturnFalse]{code/wp/return_false.js}

La risoluzione di questo problema ha infine portato ad implementare una strategia migliore per la registrazione degli eventi, che evita il verificarsi di situazioni analoghe.

Essa consiste nello sfruttare la prima fase di propagazione degli eventi, definita dalla specifica Document Object Model Level 3 [http://www.w3.org/TR/DOM-Level-3-Events/]. Come descritto in precedenza, in questa fase gli eventi vengono propagati in maniera top-down nell'albero, ed è possibile usare il parametro \verb|useCapture| del metodo \verb|addEventListener| per associare una funzione di callback che intercetta l'evento esclusivamente durante questa fase.

Così facendo l'evento viene comunque registrato, anche se il codice Javascript presente nell'applicazione sotto esame ne annulla la propagazione per qualche motivo. Di fatto viene ridotta notevolmente la possibilità di interferenze tra il codice iniettato e quello definito dall'applicazione. Nel listato ~\ref{code:eventCapturing} viene mostrato un esempio di questa soluzione.

\lstinputlisting[language=Javascript, caption={Definizione degli event handler per la fase di capturing}, label=code:eventCapturing]{code/wp/capture.js}

\subsubsection{Verifica dell'inserimento e del filtro di ricerca}

Una volta assegnata la categoria e il titolo dell'articolo, si preme sul pulsante "Publish", viene registrata l'azione corrispondente e l'articolo viene salvato nel database dell'applicazione. 

A questo punto si vuole verificare che l'utente si ritrovi sulla pagina di modifica del post appena pubblicato e che venga mostrato un messaggio di conferma. Tramite la finestra di dialogo si crea una nuova asserzione e si seleziona il messaggio con sfondo giallo, per il quale viene restituito il selettore \verb|#message|. Si comunica anche di voler controllare che questo elemento contenga la stringa "post published".

Si verifica poi che il campo di testo per il titolo dell'articolo contenga il valore che si era immesso nel passaggio precedente.

Successivamente, si clicca nella voce del menù principale che porta all'elenco degli articoli salvati. Da questa pagina si seleziona dal filtro di ricerca la voce corrispondente al nome della nuova categoria creata, alla quale è stato assegnato l'articolo appena pubblicato. L'azione viene registrata grazie all'evento \verb|change| che si verifica quando l'utente modifica la voce selezionata in un tag di tipo \verb|select|. 

Per effettuare la ricerca si registra l'azione di click sul pulsante "Filter". Nella schermata ci si aspetta di trovare un solo articolo nella categoria appena creata, pertanto si aggiunge una nuova asserzione di tipo "AssertCount" tramite la schermata in figura ~\ref{fig:assertCountDialog}. Quest'ultima permette di verificare che un dato elemento compaia un numero di volte specificato, nell'intera pagina oppure all'interno di un elemento specificato tramite un secondo selettore.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\textwidth]{images/wp_tour/9_count_dialog.png}
\caption{Finestra per creare una nuova asserzione}
\label{fig:assertCountDialog}
\end{center}
\end{figure}

\section{Descrizione del primo esperimento}

La seconda fase dell'esperimento ha permesso di verificare il grado di flessibilità raggiunto dai test definiti attraverso lo strumento realizzato. Per fare ciò si è rieseguito il test su una versione successiva della piattaforma Wordpress. Per questa seconda prova è stata usata la versione 3.1.3, che durante la fase di progetto risultava essere la più recente, poiché essa presenta alcune modifiche nel layout del pannello di amministrazione rispetto alle versioni 2.X, mentre le funzionalità rimangono pressoché inalterate.

Una volta definito il test attraverso i passi appena descritti, esso è stato esportato in formato XML. Dopodiché si è modificato l'indirizzo di partenza, affinché puntasse alla nuova versione di Wordpress installata in locale.

Affinché lo stesso test venisse eseguito senza errori su entrambe le versioni, è stato necessario modificare solamente due dei selettori generati automaticamente dallo strumento.

Nello specifico, il valore dell'attributo id del campo di testo per inserire una nuova categoria nella pagina di modifica di un articolo è stato modificato da \verb|#newcat| a \verb|#newcategory|. Poiché la modifica è avvenuta sull'attributo id, il selettore generato dallo strumento non è stato in grado di selezionare il nodo del DOM nella versione più recente della piattaforma.

Allo stesso modo, poiché nella versione più recente è stato corretto un errore di battitura per l'attributo id assegnato al pulsante per aggiungere una nuova categoria, che è passato dal valore \verb|category-add-sumbit| al valore \verb|category-add-submit|, è stato necessario adattare il selettore ottenuto registrando il test.

Durante queste prove è stata inoltre dimostrata in vari casi l'utilità pratica dell'algoritmo che si occupa di fornire selettori alternativi a quelli definiti in fase di acquisizione del test, nel caso in cui non sia possibile reperire l'elemento al primo tentativo.

Uno dei casi interessanti ha riguardato l'elenco principale degli articoli salvati nel database. Le righe della tabella generate in maniera dinamica possiedono un attributo id, che ha come suffisso la chiave primaria del record nel database corrispondente a ciascun articolo, come è possibile osservare in figura ~\ref{fig:trId}. Se il selettore generato per individuare il link contenuto all'interno della prima cella di ogni riga contenesse l'attributo id assegnato al tag \verb|tr|, i risultati dei test sarebbero condizionati dal valore della chiave primaria di ogni record nel database e l'azione definita potrebbe fallire o avere successo a seconda di questo fattore, che dovrebbe essere invece un dettaglio implementativo non influente ai fini delle verifiche effettuate.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\textwidth]{images/wp_tour/10_firebug_tr_id.png}
\caption{Attributi id per le righe della tabella contenente gli articoli salvati}
\label{fig:trId}
\end{center}
\end{figure}

L'algoritmo di generazione dei selettori riconosce questo schema tramite un'espressione regolare, siccome è tipico di molte applicazioni in cui il contenuto viene generato dinamicamente, ed ignora l'attributo id, riferendosi poi a quello successivo trovato risalendo nella gerarchia dell'albero DOM. Si confrontino come esempio i due selettori generati senza questo accorgimento per identificare il link alla pagina di modifica di un articolo, in base al frammento di codice HTML mostrato in figura ~\ref{fig:trId}:

Selettore generato senza modifiche:  \verb|#post-62 a:icontains(post+title)| 
\newline
Selettore generato tenendo conto dell'attributi id generato dinamicamente:  \verb|#the-list a:icontains(post+title)| 

Pertanto, è stato possibile eseguire lo stesso test sulle due versioni nonostante esse utilizzino due database separati, con valori differenti per le chiavi primarie dei record.

\bibliography{biblio}
\bibliographystyle{plainnat}

\end{document}

